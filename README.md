# Рациональные числа

Класс неизменяемого рационального числа, предоставляющий следующие операции:

- Конструирование без аргументов
- Конструирование от `int64_t`
- Конструирование от числителя и знаменателя (типа `int64_t`)
- Числитель: `int64_t numerator()`
- Знаменатель: `uint64_t denominator()`
- Явное приведение к `double`
- Перевод в строку: `std::string str()`
- Сложение: `+`, `+=`
- Вычитание: `-`, `-=`
- Умножение: `*`, `*=`
- Деление: `/`, `/=`
- Унарный минус: `-`
- Операции сравнения: `==`, `!=`, `<`, `<=`, `>`, `>=`
- Вывод в поток: `<<`

Дробь всегда хранится в сокращённом состоянии.

# Арифметические выражения

Пакет классов для работы с вычислимыми арифметическими выражениями над типом `Fraction`.

Виды выражений:

- `Const` (в конструкторе передаётся значение)
- `Variable` (в конструкторе передаётся имя переменной)
- `Negate` (унарный минус)
- `Add` (сложение)
- `Subtract` (вычитание)
- `Multiply` (умножение)
- `Divide` (деление)

Пример конструирования выражения `2 * x + 1`:

```cpp
const Add expr(Multiply(Const(2), Variable("x")), Const(1));
```

Над выражениями должны быть реализованы соответствующие арифметические операторы.
Таким образом, предыдущий пример можно было бы записать так:

```cpp
const Add expr = Const(2) * Variable("x") + Const(1);
```

Аргументом методу `eval` передаётся отображение из имени переменной в её значение.
Он возвращает результат выражения, используя переданные значения вместо переменных.

```cpp
const Fraction result = expr.eval({
    {"x", Fraction(100)}
    {"y", Fraction(42)}
}); // 201
```

Вспомогательный метод `clone` возвращает указатель на такое же выражение, как то, на котором он вызван,
однако владение над указателем принадлежит вызвавшему метод.

Для класса `Expression` реализован оператор вывода в поток.
